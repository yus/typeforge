<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FontForge | Full-Screen Generative Art</title>
    <style>
        :root {
            --primary-color: #0a0a12;
            --secondary-color: #161625;
            --accent-color: #4ecdc4;
            --text-color: #e6e6e6;
            --font-sample: 'Courier New', monospace;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }
        
        /* Full-screen canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--primary-color);
            overflow: hidden;
        }
        
        #artCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Typing interface that appears on focus */
        .typing-interface {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 18, 0.95);
            border-top: 2px solid var(--accent-color);
            padding: 15px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 100;
        }
        
        .typing-interface.active {
            transform: translateY(0);
        }
        
        .type-input {
            width: 100%;
            padding: 15px;
            background: rgba(22, 22, 37, 0.9);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            color: var(--text-color);
            font-family: var(--font-sample);
            font-size: 18px;
            resize: none;
            margin-bottom: 15px;
            -webkit-appearance: none;
        }
        
        .type-input:focus {
            outline: none;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }
        
        /* Controls bar */
        .controls-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 18, 0.9);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
            border-bottom: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .app-title {
            font-family: var(--font-sample);
            font-size: 1.5rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            background: var(--accent-color);
            color: var(--primary-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: var(--font-sample);
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #ff6b6b;
            transform: translateY(-2px);
        }
        
        /* Glyph palette */
        .glyph-palette {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(10, 10, 18, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 40;
        }
        
        .glyph-option {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(22, 22, 37, 0.9);
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            cursor: pointer;
            font-family: var(--font-sample);
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }
        
        .glyph-option:hover, .glyph-option.active {
            background: var(--accent-color);
            color: var(--primary-color);
            transform: scale(1.1);
        }
        
        /* Mode selector */
        .mode-selector {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(10, 10, 18, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 40;
        }
        
        .mode-option {
            padding: 10px 15px;
            background: rgba(22, 22, 37, 0.9);
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            cursor: pointer;
            font-family: var(--font-sample);
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .mode-option:hover, .mode-option.active {
            background: var(--accent-color);
            color: var(--primary-color);
        }
        
        /* Stats panel */
        .stats-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 18, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--accent-color);
            font-family: var(--font-sample);
            font-size: 0.9rem;
            z-index: 40;
        }
        
        .stat {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .controls-bar {
                padding: 10px;
            }
            
            .app-title {
                font-size: 1.2rem;
            }
            
            button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .glyph-palette, .mode-selector {
                position: static;
                transform: none;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                margin: 10px;
                order: -1;
            }
            
            .mobile-layout {
                display: flex;
                flex-direction: column;
            }
            
            .top-controls {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                padding: 10px;
            }
            
            .type-input {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }
        
        /* Welcome message */
        .welcome-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 18, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--accent-color);
            text-align: center;
            max-width: 500px;
            z-index: 100;
        }
        
        .welcome-message h2 {
            font-family: var(--font-sample);
            margin-bottom: 15px;
            color: var(--accent-color);
        }
        
        .welcome-message p {
            margin-bottom: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        /* Save confirmation */
        .save-confirmation {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(78, 205, 196, 0.9);
            color: var(--primary-color);
            padding: 10px 20px;
            border-radius: 5px;
            font-family: var(--font-sample);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .save-confirmation.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Controls -->
        <div class="controls-bar">
            <div class="app-title">FontForge</div>
            <div class="control-buttons">
                <button id="saveBtn">Save Art</button>
                <button id="newBtn">New Canvas</button>
            </div>
        </div>
        
        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="artCanvas"></canvas>
        </div>
        
        <!-- Typing Interface -->
        <div class="typing-interface" id="typingInterface">
            <textarea class="type-input" id="typeInput" placeholder="Type here to create art... Your masterpiece auto-saves!"></textarea>
            <div style="text-align: center; color: #4ecdc4; font-size: 0.9rem;">
                Tap outside to hide keyboard â€¢ Art auto-saves
            </div>
        </div>
        
        <!-- Glyph Palette -->
        <div class="glyph-palette" id="glyphPalette">
            <!-- Glyphs will be added by JavaScript -->
        </div>
        
        <!-- Mode Selector -->
        <div class="mode-selector" id="modeSelector">
            <!-- Modes will be added by JavaScript -->
        </div>
        
        <!-- Stats -->
        <div class="stats-panel">
            <div class="stat">
                <span>Characters:</span>
                <span id="charCount">0</span>
            </div>
            <div class="stat">
                <span>Mode:</span>
                <span id="renderMode">Spiral</span>
            </div>
        </div>
        
        <!-- Welcome Message -->
        <div class="welcome-message" id="welcomeMessage">
            <h2>Welcome to FontForge</h2>
            <p>Type to create generative art. Each character adds to your masterpiece.</p>
            <p><strong>Your art automatically saves</strong> and will be here when you return.</p>
            <button id="startBtn" style="margin-top: 15px;">Start Creating</button>
        </div>
        
        <!-- Save Confirmation -->
        <div class="save-confirmation" id="saveConfirmation">
            Art Saved!
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        
        // Application state - with auto-save
        const state = {
            charactersTyped: 0,
            renderMode: 'spiral',
            currentGlyph: 'A',
            centerX: 0,
            centerY: 0,
            angle: 0,
            radius: 0,
            growthFactor: 0.8,
            colorIndex: 0,
            artPieces: [], // Store all drawn elements for persistence
            autoSave: true
        };
        
        // Color palettes
        const palettes = {
            deepOcean: ['#0f3460', '#4ecdc4', '#ff6b6b', '#f7fff7', '#1a1a2e'],
            sunset: ['#ff9a8b', '#ff6b6b', '#ff8e53', '#ffca3a', '#8ac926'],
            forest: ['#386641', '#6a994e', '#a7c957', '#f2e8cf', '#bc4749'],
            neon: ['#ff00ff', '#00ffff', '#ffff00', '#ff0080', '#80ff00']
        };
        
        // Available glyphs
        const glyphs = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 
                       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                       '&', '#', '@', '%', '*', '+', '=', '-', '_', '~'];
        
        // Render modes
        const renderModes = [
            { id: 'spiral', name: 'Spiral' },
            { id: 'radial', name: 'Radial' },
            { id: 'wave', name: 'Wave' },
            { id: 'matrix', name: 'Matrix' }
        ];
        
        // Set canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            state.centerX = canvas.width / 2;
            state.centerY = canvas.height / 2;
            
            // Redraw all saved art pieces
            redrawCanvas();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Initialize UI
        function initializeUI() {
            // Glyph palette
            const glyphPalette = document.getElementById('glyphPalette');
            glyphs.forEach(glyph => {
                const glyphElement = document.createElement('div');
                glyphElement.className = 'glyph-option';
                if (glyph === state.currentGlyph) {
                    glyphElement.classList.add('active');
                }
                glyphElement.textContent = glyph;
                glyphElement.addEventListener('click', () => setCurrentGlyph(glyph));
                glyphPalette.appendChild(glyphElement);
            });
            
            // Mode selector
            const modeSelector = document.getElementById('modeSelector');
            renderModes.forEach(mode => {
                const modeElement = document.createElement('div');
                modeElement.className = 'mode-option';
                if (mode.id === state.renderMode) {
                    modeElement.classList.add('active');
                }
                modeElement.textContent = mode.name;
                modeElement.addEventListener('click', () => setRenderMode(mode.id));
                modeSelector.appendChild(modeElement);
            });
            
            // Typing interface
            const typeInput = document.getElementById('typeInput');
            const typingInterface = document.getElementById('typingInterface');
            
            typeInput.addEventListener('focus', () => {
                typingInterface.classList.add('active');
            });
            
            typeInput.addEventListener('blur', () => {
                // Small delay to allow clicking buttons
                setTimeout(() => {
                    typingInterface.classList.remove('active');
                }, 200);
            });
            
            typeInput.addEventListener('input', handleTyping);
            
            // Start button
            document.getElementById('startBtn').addEventListener('click', () => {
                document.getElementById('welcomeMessage').classList.add('hidden');
                typeInput.focus();
            });
            
            // Save button
            document.getElementById('saveBtn').addEventListener('click', saveArt);
            
            // New canvas button
            document.getElementById('newBtn').addEventListener('click', newCanvas);
            
            // Click anywhere on canvas to focus typing
            canvas.addEventListener('click', () => {
                typeInput.focus();
            });
        }
        
        // Set current glyph
        function setCurrentGlyph(glyph) {
            state.currentGlyph = glyph;
            document.querySelectorAll('.glyph-option').forEach(opt => {
                opt.classList.toggle('active', opt.textContent === glyph);
            });
        }
        
        // Set render mode
        function setRenderMode(mode) {
            state.renderMode = mode;
            document.querySelectorAll('.mode-option').forEach(opt => {
                opt.classList.toggle('active', opt.textContent === renderModes.find(m => m.id === mode).name);
            });
            document.getElementById('renderMode').textContent = renderModes.find(m => m.id === mode).name;
        }
        
        // Handle typing input
        function handleTyping(e) {
            const newText = e.target.value;
            const newChars = newText.length - state.charactersTyped;
            
            if (newChars > 0) {
                for (let i = 0; i < newChars; i++) {
                    addCharacterToArt(newText[state.charactersTyped + i]);
                }
                state.charactersTyped = newText.length;
                updateStats();
                
                // Auto-save after typing
                if (state.autoSave) {
                    autoSaveArt();
                }
            }
        }
        
        // Add character to art (persistent)
        function addCharacterToArt(char) {
            const artPiece = {
                char: char,
                mode: state.renderMode,
                glyph: state.currentGlyph,
                timestamp: Date.now(),
                position: {
                    x: state.centerX,
                    y: state.centerY,
                    angle: state.angle,
                    radius: state.radius
                }
            };
            
            state.artPieces.push(artPiece);
            drawArtPiece(artPiece);
            
            // Update state for next character
            state.angle += 0.15;
            state.radius += state.growthFactor;
            
            // Reset radius if it gets too large
            const maxRadius = Math.min(state.centerX, state.centerY) * 0.8;
            if (state.radius > maxRadius) {
                state.radius = 0;
                state.colorIndex = (state.colorIndex + 1) % palettes.deepOcean.length;
            }
        }
        
        // Draw a single art piece
        function drawArtPiece(artPiece) {
            const colors = palettes.deepOcean;
            const charToDraw = artPiece.glyph;
            
            switch(artPiece.mode) {
                case 'spiral':
                    drawSpiral(charToDraw, artPiece.position, colors);
                    break;
                case 'radial':
                    drawRadial(charToDraw, artPiece.position, colors);
                    break;
                case 'wave':
                    drawWave(charToDraw, artPiece.position, colors);
                    break;
                case 'matrix':
                    drawMatrix(charToDraw, artPiece.position, colors);
                    break;
            }
        }
        
        // Drawing functions
        function drawSpiral(char, position, colors) {
            const x = position.x + Math.cos(position.angle) * position.radius;
            const y = position.y + Math.sin(position.angle) * position.radius;
            
            const fontSize = Math.max(12, 14 + (position.radius / 20));
            const color = colors[Math.floor(position.angle) % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }
        
        function drawRadial(char, position, colors) {
            const segmentAngle = (2 * Math.PI) / 24;
            const currentAngle = (state.artPieces.length % 24) * segmentAngle;
            const radius = 40 + Math.floor(state.artPieces.length / 24) * 18;
            
            const x = position.x + Math.cos(currentAngle) * radius;
            const y = position.y + Math.sin(currentAngle) * radius;
            
            const fontSize = 16;
            const color = colors[state.artPieces.length % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }
        
        function drawWave(char, position, colors) {
            const waveIndex = Math.floor(state.artPieces.length / 40);
            const y = position.y + Math.sin(position.angle * 3) * 60;
            const x = position.x + (state.artPieces.length % 40) * 25 - 500;
            
            const fontSize = 18;
            const color = colors[waveIndex % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }
        
        function drawMatrix(char, position, colors) {
            const cols = 15;
            const colWidth = canvas.width / cols;
            const row = Math.floor(state.artPieces.length / cols);
            const col = state.artPieces.length % cols;
            
            const x = col * colWidth + (Math.random() * 20 - 10);
            const y = row * 30 + (Math.random() * 20 - 10);
            
            const fontSize = 16 + Math.random() * 8;
            const color = colors[col % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }
        
        // Redraw entire canvas from saved art pieces
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            state.artPieces.forEach(drawArtPiece);
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('charCount').textContent = state.charactersTyped;
        }
        
        // Auto-save art to localStorage
        function autoSaveArt() {
            const saveData = {
                artPieces: state.artPieces,
                charactersTyped: state.charactersTyped,
                timestamp: Date.now()
            };
            localStorage.setItem('fontforgeArt', JSON.stringify(saveData));
        }
        
        // Load saved art from localStorage
        function loadSavedArt() {
            const saved = localStorage.getItem('fontforgeArt');
            if (saved) {
                try {
                    const saveData = JSON.parse(saved);
                    state.artPieces = saveData.artPieces || [];
                    state.charactersTyped = saveData.charactersTyped || 0;
                    
                    if (state.artPieces.length > 0) {
                        document.getElementById('welcomeMessage').classList.add('hidden');
                        redrawCanvas();
                        updateStats();
                    }
                } catch (e) {
                    console.log('No previous art found or error loading');
                }
            }
        }
        
        // Save art (with confirmation)
        function saveArt() {
            autoSaveArt();
            showSaveConfirmation();
        }
        
        // New canvas
        function newCanvas() {
            if (confirm('Start a new canvas? Your current art will be saved.')) {
                state.artPieces = [];
                state.charactersTyped = 0;
                state.angle = 0;
                state.radius = 0;
                document.getElementById('typeInput').value = '';
                redrawCanvas();
                updateStats();
                autoSaveArt();
            }
        }
        
        // Show save confirmation
        function showSaveConfirmation() {
            const confirmation = document.getElementById('saveConfirmation');
            confirmation.classList.add('show');
            setTimeout(() => {
                confirmation.classList.remove('show');
            }, 2000);
        }
        
        // Initialize everything
        initializeUI();
        loadSavedArt();
        
        // Auto-focus on input after a short delay
        setTimeout(() => {
            if (state.artPieces.length === 0) {
                document.getElementById('typeInput').focus();
            }
        }, 1000);
    </script>
</body>
</html>
