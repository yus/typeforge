<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FontForge | Minimal Generative Art</title>
    <style>
        :root {
            --primary-color: #0a0a12;
            --secondary-color: #161625;
            --accent-color: #4ecdc4;
            --text-color: #e6e6e6;
            --font-sample: 'Courier New', monospace;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }
        
        /* Full-screen canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--primary-color);
            overflow: hidden;
        }
        
        #artCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Minimal controls bar */
        .controls-bar {
            position: fixed;
            top: 8px;
            left: 8px;
            right: 8px;
            background: rgba(10, 10, 18, 0.85);
            padding: 6px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
            border-radius: 6px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-size: 10px;
        }
        
        .app-title {
            font-family: var(--font-sample);
            font-size: 10px;
            font-weight: bold;
            color: var(--accent-color);
        }
        
        .control-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        select, button {
            padding: 4px 8px;
            background: rgba(22, 22, 37, 0.9);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-sample);
            font-size: 9px;
            transition: all 0.2s ease;
        }
        
        select {
            min-width: 70px;
        }
        
        button:hover, select:hover {
            background: var(--accent-color);
            color: var(--primary-color);
        }
        
        /* Single line input */
        .input-line {
            position: fixed;
            bottom: 8px;
            left: 8px;
            right: 8px;
            background: rgba(10, 10, 18, 0.9);
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--accent-color);
            z-index: 50;
        }
        
        .type-input {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: var(--font-sample);
            font-size: 14px;
            outline: none;
            padding: 2px 0;
        }
        
        .type-input::placeholder {
            color: rgba(78, 205, 196, 0.6);
        }
        
        /* Stats - minimal */
        .stats {
            position: fixed;
            bottom: 40px;
            right: 8px;
            background: rgba(10, 10, 18, 0.8);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-family: var(--font-sample);
            font-size: 9px;
            z-index: 40;
        }
        
        /* Angle control */
        .angle-control {
            position: fixed;
            top: 40px;
            right: 8px;
            background: rgba(10, 10, 18, 0.8);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-family: var(--font-sample);
            font-size: 9px;
            z-index: 40;
        }
        
        .angle-slider {
            width: 80px;
            margin: 4px 0;
        }
        
        /* Save confirmation */
        .save-confirmation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(78, 205, 196, 0.9);
            color: var(--primary-color);
            padding: 8px 16px;
            border-radius: 4px;
            font-family: var(--font-sample);
            font-size: 10px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .save-confirmation.show {
            opacity: 1;
        }
        
        /* Mode descriptions */
        .mode-hint {
            position: fixed;
            top: 40px;
            left: 8px;
            background: rgba(10, 10, 18, 0.8);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-family: var(--font-sample);
            font-size: 8px;
            max-width: 200px;
            z-index: 40;
            display: none;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .controls-bar {
                flex-wrap: wrap;
                gap: 4px;
            }
            
            .control-group {
                flex: 1;
                justify-content: flex-end;
            }
            
            select, button {
                flex: 1;
                min-width: 0;
            }
            
            .stats, .angle-control {
                font-size: 8px;
                padding: 4px 6px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Minimal Controls -->
        <div class="controls-bar">
            <div class="app-title">FONTFORGE</div>
            <div class="control-group">
                <select id="modeSelect">
                    <option value="spiral">Spiral</option>
                    <option value="radial">Radial</option>
                    <option value="wave">Wave</option>
                    <option value="matrix">Matrix</option>
                    <option value="freeform">Freeform</option>
                </select>
                <button id="saveBtn">SAVE</button>
                <button id="centerBtn">CENTER</button>
            </div>
        </div>
        
        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="artCanvas"></canvas>
        </div>
        
        <!-- Single Line Input -->
        <div class="input-line">
            <input type="text" class="type-input" id="typeInput" placeholder="Type to create art... (auto-saves)">
        </div>
        
        <!-- Stats -->
        <div class="stats">
            <span id="charCount">0</span> chars
        </div>
        
        <!-- Angle Control -->
        <div class="angle-control">
            <div>ANGLE: <span id="angleValue">0°</span></div>
            <input type="range" class="angle-slider" id="angleSlider" min="0" max="360" value="0" step="1">
        </div>
        
        <!-- Mode Hint -->
        <div class="mode-hint" id="modeHint"></div>
        
        <!-- Save Confirmation -->
        <div class="save-confirmation" id="saveConfirmation">
            ART SAVED
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        
        // Application state
        const state = {
            charactersTyped: 0,
            renderMode: 'spiral',
            currentAngle: 0,
            centerX: 0,
            centerY: 0,
            angle: 0,
            radius: 0,
            growthFactor: 0.8,
            colorIndex: 0,
            artPieces: [],
            autoSave: true,
            customCenter: null
        };
        
        // Color palettes
        const palettes = {
            deepOcean: ['#0f3460', '#4ecdc4', '#ff6b6b', '#f7fff7', '#1a1a2e'],
            sunset: ['#ff9a8b', '#ff6b6b', '#ff8e53', '#ffca3a', '#8ac926'],
            forest: ['#386641', '#6a994e', '#a7c957', '#f2e8cf', '#bc4749'],
            neon: ['#ff00ff', '#00ffff', '#ffff00', '#ff0080', '#80ff00']
        };
        
        // Mode descriptions
        const modeHints = {
            spiral: "Characters spiral outward from center",
            radial: "Characters arranged in circular patterns", 
            wave: "Wave-like patterns across the canvas",
            matrix: "Grid-based character placement",
            freeform: "Free placement based on typing rhythm"
        };

        // Set canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Set center - use custom center if set, otherwise screen center
            if (state.customCenter) {
                state.centerX = state.customCenter.x;
                state.centerY = state.customCenter.y;
            } else {
                state.centerX = canvas.width / 2;
                state.centerY = canvas.height / 2;
            }
            
            redrawCanvas();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Initialize UI
        function initializeUI() {
            // Mode selector
            const modeSelect = document.getElementById('modeSelect');
            modeSelect.value = state.renderMode;
            modeSelect.addEventListener('change', (e) => {
                state.renderMode = e.target.value;
                showModeHint();
                // Don't clear canvas - keep existing art
                updateModeHint();
            });

            // Angle slider
            const angleSlider = document.getElementById('angleSlider');
            const angleValue = document.getElementById('angleValue');
            
            angleSlider.addEventListener('input', (e) => {
                state.currentAngle = parseInt(e.target.value);
                angleValue.textContent = state.currentAngle + '°';
                // Apply angle to new characters without clearing
                redrawCanvas();
            });

            // Typing input
            const typeInput = document.getElementById('typeInput');
            typeInput.addEventListener('input', handleTyping);
            
            // Auto-focus input
            setTimeout(() => typeInput.focus(), 500);

            // Save button
            document.getElementById('saveBtn').addEventListener('click', saveArt);

            // Center button - set new center point
            document.getElementById('centerBtn').addEventListener('click', setNewCenter);

            // Click on canvas to set new center
            canvas.addEventListener('click', (e) => {
                setCenterFromClick(e);
            });

            // Show mode hint on hover
            modeSelect.addEventListener('mouseenter', showModeHint);
            modeSelect.addEventListener('mouseleave', hideModeHint);
            modeSelect.addEventListener('touchstart', showModeHint);

            // Hide hint after delay on mobile
            modeSelect.addEventListener('touchend', () => {
                setTimeout(hideModeHint, 2000);
            });
        }

        // Set new center from click
        function setNewCenter() {
            state.customCenter = null; // Reset to auto-center on next click
            alert('Click anywhere on canvas to set new center point');
        }

        function setCenterFromClick(e) {
            const rect = canvas.getBoundingClientRect();
            state.customCenter = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            resizeCanvas(); // This will update the center
        }

        // Handle typing input
        function handleTyping(e) {
            const newText = e.target.value;
            const newChars = newText.length - state.charactersTyped;
            
            if (newChars > 0) {
                for (let i = 0; i < newChars; i++) {
                    addCharacterToArt(newText[state.charactersTyped + i]);
                }
                state.charactersTyped = newText.length;
                updateStats();
                
                // Auto-save
                if (state.autoSave) {
                    autoSaveArt();
                }
            }
        }

        // Add character to art
        function addCharacterToArt(char) {
            const artPiece = {
                char: char,
                mode: state.renderMode,
                timestamp: Date.now(),
                position: {
                    x: state.centerX,
                    y: state.centerY,
                    angle: state.angle,
                    radius: state.radius,
                    globalAngle: state.currentAngle
                }
            };
            
            state.artPieces.push(artPiece);
            drawArtPiece(artPiece);
            
            // Update state for next character
            state.angle += 0.15;
            state.radius += state.growthFactor;
            
            // Reset radius if it gets too large
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.8;
            if (state.radius > maxRadius) {
                state.radius = 0;
                state.colorIndex = (state.colorIndex + 1) % palettes.deepOcean.length;
            }
        }

        // Draw a single art piece with rotation
        function drawArtPiece(artPiece) {
            const colors = palettes.deepOcean;
            
            // Save context for rotation
            ctx.save();
            
            // Apply global rotation if not zero
            if (artPiece.position.globalAngle !== 0) {
                ctx.translate(artPiece.position.x, artPiece.position.y);
                ctx.rotate(artPiece.position.globalAngle * Math.PI / 180);
                ctx.translate(-artPiece.position.x, -artPiece.position.y);
            }
            
            switch(artPiece.mode) {
                case 'spiral':
                    drawSpiral(artPiece.char, artPiece.position, colors);
                    break;
                case 'radial':
                    drawRadial(artPiece.char, artPiece.position, colors);
                    break;
                case 'wave':
                    drawWave(artPiece.char, artPiece.position, colors);
                    break;
                case 'matrix':
                    drawMatrix(artPiece.char, artPiece.position, colors);
                    break;
                case 'freeform':
                    drawFreeform(artPiece.char, artPiece.position, colors);
                    break;
            }
            
            // Restore context
            ctx.restore();
        }

        // Drawing functions
        function drawSpiral(char, position, colors) {
            const x = position.x + Math.cos(position.angle) * position.radius;
            const y = position.y + Math.sin(position.angle) * position.radius;
            
            const fontSize = Math.max(10, 12 + (position.radius / 25));
            const color = colors[Math.floor(position.angle * 10) % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }

        function drawRadial(char, position, colors) {
            const segmentAngle = (2 * Math.PI) / 24;
            const currentAngle = (state.artPieces.length % 24) * segmentAngle;
            const radius = 30 + Math.floor(state.artPieces.length / 24) * 15;
            
            const x = position.x + Math.cos(currentAngle) * radius;
            const y = position.y + Math.sin(currentAngle) * radius;
            
            const fontSize = 14;
            const color = colors[state.artPieces.length % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }

        function drawWave(char, position, colors) {
            const waveIndex = Math.floor(state.artPieces.length / 30);
            const y = position.y + Math.sin(position.angle * 2) * 40;
            const x = position.x + (state.artPieces.length % 30) * 20 - 300;
            
            const fontSize = 16;
            const color = colors[waveIndex % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }

        function drawMatrix(char, position, colors) {
            const cols = Math.floor(canvas.width / 30);
            const row = Math.floor(state.artPieces.length / cols);
            const col = state.artPieces.length % cols;
            
            const x = col * 30 + (Math.random() * 10 - 5);
            const y = row * 25 + (Math.random() * 10 - 5);
            
            const fontSize = 12 + Math.random() * 6;
            const color = colors[col % colors.length];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }

        function drawFreeform(char, position, colors) {
            // Freeform uses typing rhythm for placement
            const timeVar = (Date.now() % 1000) / 1000;
            const x = position.x + Math.cos(timeVar * Math.PI * 2) * (50 + position.radius);
            const y = position.y + Math.sin(timeVar * Math.PI * 2) * (50 + position.radius);
            
            const fontSize = 14 + Math.random() * 8;
            const color = colors[Math.floor(timeVar * colors.length)];
            
            ctx.font = `bold ${fontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, x, y);
        }

        // Redraw entire canvas
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            state.artPieces.forEach(drawArtPiece);
        }

        // Update statistics
        function updateStats() {
            document.getElementById('charCount').textContent = state.charactersTyped;
        }

        // Show mode hint
        function showModeHint() {
            const hint = document.getElementById('modeHint');
            hint.textContent = modeHints[state.renderMode] || "";
            hint.style.display = 'block';
        }

        function hideModeHint() {
            document.getElementById('modeHint').style.display = 'none';
        }

        function updateModeHint() {
            const hint = document.getElementById('modeHint');
            hint.textContent = modeHints[state.renderMode] || "";
        }

        // Auto-save art
        function autoSaveArt() {
            const saveData = {
                artPieces: state.artPieces,
                charactersTyped: state.charactersTyped,
                customCenter: state.customCenter,
                renderMode: state.renderMode,
                currentAngle: state.currentAngle,
                timestamp: Date.now()
            };
            localStorage.setItem('fontforgeArt', JSON.stringify(saveData));
        }

        // Load saved art
        function loadSavedArt() {
            const saved = localStorage.getItem('fontforgeArt');
            if (saved) {
                try {
                    const saveData = JSON.parse(saved);
                    state.artPieces = saveData.artPieces || [];
                    state.charactersTyped = saveData.charactersTyped || 0;
                    state.customCenter = saveData.customCenter || null;
                    state.renderMode = saveData.renderMode || 'spiral';
                    state.currentAngle = saveData.currentAngle || 0;
                    
                    // Update UI
                    document.getElementById('modeSelect').value = state.renderMode;
                    document.getElementById('angleSlider').value = state.currentAngle;
                    document.getElementById('angleValue').textContent = state.currentAngle + '°';
                    
                    if (state.artPieces.length > 0) {
                        redrawCanvas();
                        updateStats();
                    }
                } catch (e) {
                    console.log('No previous art found');
                }
            }
        }

        // Save art with confirmation
        function saveArt() {
            autoSaveArt();
            showSaveConfirmation();
        }

        // Show save confirmation
        function showSaveConfirmation() {
            const confirmation = document.getElementById('saveConfirmation');
            confirmation.classList.add('show');
            setTimeout(() => {
                confirmation.classList.remove('show');
            }, 1500);
        }

        // Initialize everything
        initializeUI();
        loadSavedArt();
        updateModeHint();
    </script>
</body>
</html>
