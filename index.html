<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FontForge | Canvas Exploration</title>
    <style>
        :root {
            --primary-color: #0a0a12;
            --secondary-color: #161625;
            --accent-color: #4ecdc4;
            --text-color: #e6e6e6;
            --font-sample: 'Courier New', monospace;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }
        
        /* Full-screen canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--primary-color);
            overflow: hidden;
        }
        
        #artCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Minimal controls bar */
        .controls-bar {
            position: fixed;
            top: 8px;
            left: 8px;
            right: 8px;
            background: rgba(10, 10, 18, 0.92);
            padding: 6px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
            border-radius: 6px;
            border: 1px solid rgba(78, 205, 196, 0.4);
            font-size: 10px;
            backdrop-filter: blur(10px);
        }
        
        .app-title {
            font-family: var(--font-sample);
            font-size: 10px;
            font-weight: bold;
            color: var(--accent-color);
        }
        
        .control-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        
        select, button {
            padding: 4px 8px;
            background: rgba(22, 22, 37, 0.9);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-sample);
            font-size: 9px;
            transition: all 0.2s ease;
        }
        
        select {
            min-width: 70px;
        }
        
        button:hover, select:hover {
            background: var(--accent-color);
            color: var(--primary-color);
        }
        
        /* Single line input */
        .input-line {
            position: fixed;
            bottom: 8px;
            left: 8px;
            right: 8px;
            background: rgba(10, 10, 18, 0.92);
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--accent-color);
            z-index: 50;
            backdrop-filter: blur(10px);
        }
        
        .type-input {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-family: var(--font-sample);
            font-size: 14px;
            outline: none;
            padding: 2px 0;
        }
        
        .type-input::placeholder {
            color: rgba(78, 205, 196, 0.6);
        }
        
        /* Stats - minimal */
        .stats {
            position: fixed;
            bottom: 40px;
            right: 8px;
            background: rgba(10, 10, 18, 0.85);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-family: var(--font-sample);
            font-size: 9px;
            z-index: 40;
            backdrop-filter: blur(5px);
        }
        
        /* Exploration controls */
        .exploration-controls {
            position: fixed;
            top: 40px;
            right: 8px;
            background: rgba(10, 10, 18, 0.85);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-family: var(--font-sample);
            font-size: 9px;
            z-index: 40;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 120px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .control-label {
            color: var(--accent-color);
        }
        
        .control-value {
            color: var(--text-color);
            min-width: 30px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 2px 0;
        }
        
        /* Mode descriptions */
        .mode-hint {
            position: fixed;
            top: 40px;
            left: 8px;
            background: rgba(10, 10, 18, 0.85);
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            font-family: var(--font-sample);
            font-size: 8px;
            max-width: 200px;
            z-index: 40;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        /* Save confirmation */
        .save-confirmation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(78, 205, 196, 0.9);
            color: var(--primary-color);
            padding: 8px 16px;
            border-radius: 4px;
            font-family: var(--font-sample);
            font-size: 10px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }
        
        .save-confirmation.show {
            opacity: 1;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .controls-bar {
                flex-wrap: wrap;
                gap: 4px;
            }
            
            .control-group {
                flex: 1;
                justify-content: flex-end;
            }
            
            select, button {
                flex: 1;
                min-width: 0;
            }
            
            .stats, .exploration-controls {
                font-size: 8px;
                padding: 4px 6px;
            }
            
            .exploration-controls {
                min-width: 110px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Minimal Controls -->
        <div class="controls-bar">
            <div class="app-title">FONTFORGE EXPLORER</div>
            <div class="control-group">
                <select id="modeSelect">
                    <option value="wanderer">Wanderer</option>
                    <option value="conway">Conway Life</option>
                    <option value="mountain">Mountain Builder</option>
                    <option value="river">River Flow</option>
                    <option value="constellation">Constellation</option>
                    <option value="weather">Weather System</option>
                </select>
                <button id="saveBtn">SAVE</button>
                <button id="exploreBtn">EXPLORE</button>
            </div>
        </div>
        
        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="artCanvas"></canvas>
        </div>
        
        <!-- Single Line Input -->
        <div class="input-line">
            <input type="text" class="type-input" id="typeInput" placeholder="Type to explore the canvas... each word creates landscapes...">
        </div>
        
        <!-- Stats -->
        <div class="stats">
            <span id="charCount">0</span> chars • <span id="explorationPercent">0%</span> explored
        </div>
        
        <!-- Exploration Controls -->
        <div class="exploration-controls">
            <div class="control-row">
                <span class="control-label">SPREAD</span>
                <span class="control-value" id="spreadValue">50</span>
            </div>
            <input type="range" id="spreadSlider" min="10" max="200" value="50">
            
            <div class="control-row">
                <span class="control-label">DENSITY</span>
                <span class="control-value" id="densityValue">3</span>
            </div>
            <input type="range" id="densitySlider" min="1" max="10" value="3">
            
            <div class="control-row">
                <span class="control-label">ENERGY</span>
                <span class="control-value" id="energyValue">75</span>
            </div>
            <input type="range" id="energySlider" min="10" max="100" value="75">
        </div>
        
        <!-- Mode Hint -->
        <div class="mode-hint" id="modeHint"></div>
        
        <!-- Save Confirmation -->
        <div class="save-confirmation" id="saveConfirmation">
            EXPLORATION SAVED
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        
        // Exploration state
        const state = {
            charactersTyped: 0,
            renderMode: 'wanderer',
            explorationMap: new Map(), // Tracks explored areas
            currentPosition: { x: 0, y: 0 },
            explorationHistory: [],
            spread: 50,
            density: 3,
            energy: 75,
            colorCycle: 0,
            mood: 0.5,
            motivation: 0.5,
            explorationBounds: {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity
            }
        };

        // Exploration parameters
        const explorationParams = {
            wanderer: { spread: 80, density: 2, energy: 60 },
            conway: { spread: 30, density: 5, energy: 90 },
            mountain: { spread: 120, density: 1, energy: 40 },
            river: { spread: 150, density: 2, energy: 70 },
            constellation: { spread: 200, density: 1, energy: 30 },
            weather: { spread: 100, density: 4, energy: 80 }
        };

        // Mode descriptions
        const modeHints = {
            wanderer: "Characters wander freely, exploring unknown territories",
            conway: "Game of Life rules - characters create living patterns", 
            mountain: "Builds mountainous terrain with altitude variations",
            river: "Flowing patterns that carve paths through the landscape",
            constellation: "Starry patterns connecting distant points",
            weather: "Dynamic systems with storms, clouds, and clearings"
        };

        // Color palettes for different moods
        const moodPalettes = {
            energetic: ['#ff6b6b', '#ffa726', '#ffee58', '#4ecdc4', '#45b7d1'],
            calm: ['#8ac6d1', '#bbded6', '#fae3d9', '#ffb6b9', '#61c0bf'],
            mysterious: ['#6a0572', '#ab83a1', '#c8b6ff', '#b8c0ff', '#bbd0ff'],
            natural: ['#386641', '#6a994e', '#a7c957', '#f2e8cf', '#bc4749']
        };

        // Set canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize exploration from center
            state.currentPosition = {
                x: canvas.width / 2,
                y: canvas.height / 2
            };
            
            // Reset exploration bounds
            state.explorationBounds = {
                minX: state.currentPosition.x,
                maxX: state.currentPosition.x,
                minY: state.currentPosition.y,
                maxY: state.currentPosition.y
            };
            
            redrawCanvas();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Initialize UI
        function initializeUI() {
            // Mode selector
            const modeSelect = document.getElementById('modeSelect');
            modeSelect.value = state.renderMode;
            modeSelect.addEventListener('change', (e) => {
                state.renderMode = e.target.value;
                updateExplorationParams();
                showModeHint();
                updateModeHint();
            });

            // Exploration sliders
            initializeSliders();

            // Typing input
            const typeInput = document.getElementById('typeInput');
            typeInput.addEventListener('input', handleTyping);
            
            // Auto-focus input
            setTimeout(() => typeInput.focus(), 500);

            // Save button
            document.getElementById('saveBtn').addEventListener('click', saveExploration);

            // Explore button - auto-explore
            document.getElementById('exploreBtn').addEventListener('click', autoExplore);

            // Show mode hint on hover
            modeSelect.addEventListener('mouseenter', showModeHint);
            modeSelect.addEventListener('mouseleave', hideModeHint);
            modeSelect.addEventListener('touchstart', showModeHint);

            // Hide hint after delay on mobile
            modeSelect.addEventListener('touchend', () => {
                setTimeout(hideModeHint, 2000);
            });

            // Initial exploration
            addInitialExploration();
        }

        function initializeSliders() {
            // Spread slider
            const spreadSlider = document.getElementById('spreadSlider');
            const spreadValue = document.getElementById('spreadValue');
            spreadSlider.value = state.spread;
            spreadValue.textContent = state.spread;
            spreadSlider.addEventListener('input', (e) => {
                state.spread = parseInt(e.target.value);
                spreadValue.textContent = state.spread;
            });

            // Density slider
            const densitySlider = document.getElementById('densitySlider');
            const densityValue = document.getElementById('densityValue');
            densitySlider.value = state.density;
            densityValue.textContent = state.density;
            densitySlider.addEventListener('input', (e) => {
                state.density = parseInt(e.target.value);
                densityValue.textContent = state.density;
            });

            // Energy slider
            const energySlider = document.getElementById('energySlider');
            const energyValue = document.getElementById('energyValue');
            energySlider.value = state.energy;
            energyValue.textContent = state.energy;
            energySlider.addEventListener('input', (e) => {
                state.energy = parseInt(e.target.value);
                energyValue.textContent = state.energy;
            });
        }

        function updateExplorationParams() {
            const params = explorationParams[state.renderMode];
            if (params) {
                state.spread = params.spread;
                state.density = params.density;
                state.energy = params.energy;
                
                // Update sliders
                document.getElementById('spreadSlider').value = state.spread;
                document.getElementById('densitySlider').value = state.density;
                document.getElementById('energySlider').value = state.energy;
                document.getElementById('spreadValue').textContent = state.spread;
                document.getElementById('densityValue').textContent = state.density;
                document.getElementById('energyValue').textContent = state.energy;
            }
        }

        // Handle typing input - each character explores new territory
        function handleTyping(e) {
            const newText = e.target.value;
            const newChars = newText.length - state.charactersTyped;
            
            if (newChars > 0) {
                for (let i = 0; i < newChars; i++) {
                    const char = newText[state.charactersTyped + i];
                    exploreWithCharacter(char);
                }
                state.charactersTyped = newText.length;
                updateStats();
                
                // Auto-save
                autoSaveExploration();
            }
        }

        // Explore canvas with a character
        function exploreWithCharacter(char) {
            const exploration = {
                char: char,
                mode: state.renderMode,
                timestamp: Date.now(),
                position: { ...state.currentPosition },
                energy: state.energy / 100,
                mood: state.mood,
                motivation: state.motivation
            };
            
            // Add to history
            state.explorationHistory.push(exploration);
            
            // Mark area as explored
            const gridX = Math.floor(exploration.position.x / 10);
            const gridY = Math.floor(exploration.position.y / 10);
            const key = `${gridX},${gridY}`;
            state.explorationMap.set(key, true);
            
            // Update exploration bounds
            state.explorationBounds.minX = Math.min(state.explorationBounds.minX, exploration.position.x);
            state.explorationBounds.maxX = Math.max(state.explorationBounds.maxX, exploration.position.x);
            state.explorationBounds.minY = Math.min(state.explorationBounds.minY, exploration.position.y);
            state.explorationBounds.maxY = Math.max(state.explorationBounds.maxY, exploration.position.y);
            
            // Draw the exploration
            drawExploration(exploration);
            
            // Move to next position based on mode and character
            moveExplorer(char);
            
            // Update mood and motivation based on exploration
            updatePsychologicalState(char);
        }

        // Move explorer to new position
        function moveExplorer(char) {
            const charCode = char.charCodeAt(0);
            const angle = (charCode * 137.5) % 360; // Golden angle distribution
            const distance = (state.spread / 100) * 50 + (charCode % 20);
            
            let newX = state.currentPosition.x + Math.cos(angle * Math.PI / 180) * distance;
            let newY = state.currentPosition.y + Math.sin(angle * Math.PI / 180) * distance;
            
            // Apply mode-specific behavior
            switch(state.renderMode) {
                case 'conway':
                    // Conway-like movement - prefer unexplored areas
                    if (Math.random() > 0.7) {
                        newX += (Math.random() - 0.5) * state.spread;
                        newY += (Math.random() - 0.5) * state.spread;
                    }
                    break;
                case 'mountain':
                    // Mountain building - tend upward
                    newY -= (state.energy / 100) * 20;
                    break;
                case 'river':
                    // River flow - horizontal tendency
                    newX += (state.energy / 100) * 30;
                    break;
                case 'constellation':
                    // Constellation - large jumps
                    if (charCode % 5 === 0) {
                        newX = Math.random() * canvas.width;
                        newY = Math.random() * canvas.height;
                    }
                    break;
                case 'weather':
                    // Weather patterns - chaotic movement
                    newX += (Math.random() - 0.5) * state.spread * 2;
                    newY += (Math.random() - 0.5) * state.spread;
                    break;
            }
            
            // Keep within reasonable bounds with wrap-around
            newX = (newX + canvas.width) % canvas.width;
            newY = (newY + canvas.height) % canvas.height;
            
            state.currentPosition.x = newX;
            state.currentPosition.y = newY;
        }

        // Update psychological state based on character and exploration
        function updatePsychologicalState(char) {
            const charCode = char.charCodeAt(0);
            
            // Mood changes based on vowel/consonant and position
            if ('aeiouAEIOU'.includes(char)) {
                state.mood = Math.min(1, state.mood + 0.02);
            } else {
                state.mood = Math.max(0, state.mood - 0.01);
            }
            
            // Motivation based on exploration progress
            const exploredArea = calculateExploredArea();
            state.motivation = exploredArea / 100;
            
            // Add some randomness
            state.mood += (Math.random() - 0.5) * 0.05;
            state.motivation += (Math.random() - 0.5) * 0.03;
            
            // Clamp values
            state.mood = Math.max(0, Math.min(1, state.mood));
            state.motivation = Math.max(0, Math.min(1, state.motivation));
        }

        // Draw a single exploration
        function drawExploration(exploration) {
            const colors = getMoodPalette();
            const baseSize = 8 + (state.energy / 100) * 16;
            
            switch(exploration.mode) {
                case 'wanderer':
                    drawWanderer(exploration, colors, baseSize);
                    break;
                case 'conway':
                    drawConway(exploration, colors, baseSize);
                    break;
                case 'mountain':
                    drawMountain(exploration, colors, baseSize);
                    break;
                case 'river':
                    drawRiver(exploration, colors, baseSize);
                    break;
                case 'constellation':
                    drawConstellation(exploration, colors, baseSize);
                    break;
                case 'weather':
                    drawWeather(exploration, colors, baseSize);
                    break;
            }
        }

        // Drawing functions for different exploration modes
        function drawWanderer(exploration, colors, baseSize) {
            const size = baseSize * (0.8 + exploration.mood * 0.4);
            const color = colors[Math.floor(exploration.mood * (colors.length - 1))];
            const opacity = 0.7 + exploration.motivation * 0.3;
            
            ctx.globalAlpha = opacity;
            ctx.font = `bold ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(exploration.char, exploration.position.x, exploration.position.y);
            ctx.globalAlpha = 1;
        }

        function drawConway(exploration, colors, baseSize) {
            const neighbors = countNeighbors(exploration.position);
            const size = baseSize * (0.5 + neighbors * 0.3);
            const color = colors[neighbors % colors.length];
            
            ctx.font = `bold ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(exploration.char, exploration.position.x, exploration.position.y);
            
            // Draw connections to neighbors
            if (neighbors > 1) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                drawConnections(exploration.position);
            }
        }

        function drawMountain(exploration, colors, baseSize) {
            const altitude = 1 - (exploration.position.y / canvas.height);
            const size = baseSize * (0.3 + altitude * 0.7);
            const colorIndex = Math.floor(altitude * (colors.length - 1));
            const color = colors[colorIndex];
            
            ctx.font = `bold ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(exploration.char, exploration.position.x, exploration.position.y);
        }

        function drawRiver(exploration, colors, baseSize) {
            const flow = exploration.position.x / canvas.width;
            const size = baseSize * (0.4 + Math.sin(flow * Math.PI * 2) * 0.3);
            const color = colors[Math.floor(flow * (colors.length - 1))];
            
            ctx.font = `bold ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(exploration.char, exploration.position.x, exploration.position.y);
            
            // Draw flow lines
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(exploration.position.x - 20, exploration.position.y);
            ctx.lineTo(exploration.position.x + 20, exploration.position.y);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawConstellation(exploration, colors, baseSize) {
            const brightness = exploration.motivation;
            const size = baseSize * (0.2 + brightness * 0.8);
            const color = colors[Math.floor(brightness * (colors.length - 1))];
            
            ctx.font = `bold ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText('•', exploration.position.x, exploration.position.y);
            
            // Draw constellation lines
            if (state.explorationHistory.length > 1) {
                const prev = state.explorationHistory[state.explorationHistory.length - 2];
                const distance = Math.sqrt(
                    Math.pow(exploration.position.x - prev.position.x, 2) +
                    Math.pow(exploration.position.y - prev.position.y, 2)
                );
                
                if (distance < 200) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 0.5;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(prev.position.x, prev.position.y);
                    ctx.lineTo(exploration.position.x, exploration.position.y);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }

        function drawWeather(exploration, colors, baseSize) {
            const turbulence = exploration.mood;
            const size = baseSize * (0.5 + turbulence * 0.5);
            const color = colors[Math.floor(turbulence * (colors.length - 1))];
            const char = turbulence > 0.7 ? '⚡' : turbulence > 0.4 ? '☁️' : '○';
            
            ctx.font = `bold ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-sample')}`;
            ctx.fillStyle = color;
            ctx.fillText(char, exploration.position.x, exploration.position.y);
        }

        // Helper functions
        function countNeighbors(position) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const gridX = Math.floor((position.x + dx * 20) / 10);
                    const gridY = Math.floor((position.y + dy * 20) / 10);
                    const key = `${gridX},${gridY}`;
                    if (state.explorationMap.has(key)) count++;
                }
            }
            return count;
        }

        function drawConnections(position) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const gridX = Math.floor((position.x + dx * 20) / 10);
                    const gridY = Math.floor((position.y + dy * 20) / 10);
                    const key = `${gridX},${gridY}`;
                    if (state.explorationMap.has(key)) {
                        ctx.beginPath();
                        ctx.moveTo(position.x, position.y);
                        ctx.lineTo(position.x + dx * 20, position.y + dy * 20);
                        ctx.stroke();
                    }
                }
            }
        }

        function getMoodPalette() {
            if (state.mood > 0.7) return moodPalettes.energetic;
            if (state.mood > 0.4) return moodPalettes.calm;
            if (state.motivation > 0.6) return moodPalettes.mysterious;
            return moodPalettes.natural;
        }

        function calculateExploredArea() {
            const gridCells = state.explorationMap.size;
            const totalGridCells = Math.floor(canvas.width / 10) * Math.floor(canvas.height / 10);
            return Math.min(100, (gridCells / totalGridCells) * 100);
        }

        // Redraw entire canvas
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            state.explorationHistory.forEach(drawExploration);
        }

        // Update statistics
        function updateStats() {
            document.getElementById('charCount').textContent = state.charactersTyped;
            const exploredPercent = calculateExploredArea();
            document.getElementById('explorationPercent').textContent = exploredPercent.toFixed(1) + '%';
        }

        // Show mode hint
        function showModeHint() {
            const hint = document.getElementById('modeHint');
            hint.textContent = modeHints[state.renderMode] || "";
            hint.style.display = 'block';
        }

        function hideModeHint() {
            document.getElementById('modeHint').style.display = 'none';
        }

        function updateModeHint() {
            const hint = document.getElementById('modeHint');
            hint.textContent = modeHints[state.renderMode] || "";
        }

        // Auto-explore function
        function autoExplore() {
            const sampleText = "explore discover create imagine wander journey adventure mystery wonder beauty chaos order pattern rhythm flow energy life universe cosmos infinite possibilities ";
            let i = 0;
            
            const exploreInterval = setInterval(() => {
                if (i < sampleText.length) {
                    exploreWithCharacter(sampleText[i]);
                    i++;
                    updateStats();
                } else {
                    clearInterval(exploreInterval);
                }
            }, 50);
        }

        // Add initial exploration
        function addInitialExploration() {
            exploreWithCharacter('●');
        }

        // Auto-save exploration
        function autoSaveExploration() {
            const saveData = {
                explorationHistory: state.explorationHistory,
                charactersTyped: state.charactersTyped,
                renderMode: state.renderMode,
                spread: state.spread,
                density: state.density,
                energy: state.energy,
                timestamp: Date.now()
            };
            localStorage.setItem('fontforgeExploration', JSON.stringify(saveData));
        }

        // Load saved exploration
        function loadSavedExploration() {
            const saved = localStorage.getItem('fontforgeExploration');
            if (saved) {
                try {
                    const saveData = JSON.parse(saved);
                    state.explorationHistory = saveData.explorationHistory || [];
                    state.charactersTyped = saveData.charactersTyped || 0;
                    state.renderMode = saveData.renderMode || 'wanderer';
                    state.spread = saveData.spread || 50;
                    state.density = saveData.density || 3;
                    state.energy = saveData.energy || 75;
                    
                    // Rebuild exploration map
                    state.explorationMap.clear();
                    state.explorationHistory.forEach(exp => {
                        const gridX = Math.floor(exp.position.x / 10);
                        const gridY = Math.floor(exp.position.y / 10);
                        const key = `${gridX},${gridY}`;
                        state.explorationMap.set(key, true);
                    });
                    
                    // Update UI
                    document.getElementById('modeSelect').value = state.renderMode;
                    document.getElementById('spreadSlider').value = state.spread;
                    document.getElementById('densitySlider').value = state.density;
                    document.getElementById('energySlider').value = state.energy;
                    document.getElementById('spreadValue').textContent = state.spread;
                    document.getElementById('densityValue').textContent = state.density;
                    document.getElementById('energyValue').textContent = state.energy;
                    
                    if (state.explorationHistory.length > 0) {
                        // Set current position to last exploration
                        const lastExp = state.explorationHistory[state.explorationHistory.length - 1];
                        state.currentPosition = { ...lastExp.position };
                        
                        redrawCanvas();
                        updateStats();
                    }
                } catch (e) {
                    console.log('No previous exploration found');
                }
            }
        }

        // Save exploration with confirmation
        function saveExploration() {
            autoSaveExploration();
            showSaveConfirmation();
        }

        // Show save confirmation
        function showSaveConfirmation() {
            const confirmation = document.getElementById('saveConfirmation');
            confirmation.classList.add('show');
            setTimeout(() => {
                confirmation.classList.remove('show');
            }, 1500);
        }

        // Initialize everything
        initializeUI();
        loadSavedExploration();
        updateModeHint();
        updateExplorationParams();
    </script>
</body>
</html>
